<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Terminal</title>
    <link rel="stylesheet" href="node_modules/@xterm/xterm/css/xterm.css">
    <style>
        :root {
            --bg-primary: transparent;
            --bg-secondary: transparent;
            --bg-tertiary: rgba(255, 255, 255, 0.06);
            --bg-accent-focused: rgba(255, 255, 255, 0.22);
            --border-color: transparent;
            --text-primary: #ffffff;
            --text-secondary: rgba(255, 255, 255, 0.6);
            --accent: #58a6ff;
            --tab-height: 26px;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: transparent;
            overflow: hidden;
            height: 100vh;
            display: flex;
            flex-direction: column;
            color: var(--text-primary);
        }

        #titlebar {
            height: 50px;
            background: transparent;
            -webkit-app-region: drag;
            display: flex;
            align-items: center;
            padding-left: 76px;
            padding-right: 12px;
            flex-shrink: 0;
            transition: padding-left 0.2s ease;
        }

        body.fullscreen #titlebar {
            padding-left: 12px;
        }

        #tabs {
            display: flex;
            height: var(--tab-height);
            align-items: center;
            gap: 6px;
            overflow-x: auto;
            overflow-y: hidden;
            flex: 1;
            min-width: 0;
            scrollbar-width: none;
        }

        #tabs::-webkit-scrollbar {
            display: none;
        }

        .tab {
            height: 100%;
            min-width: 100px;
            max-width: fit-content;
            background: rgba(255, 255, 255, 0.05);
            border: none;
            border-radius: 6px;
            display: flex;
            align-items: center;
            padding: 0 10px;
            cursor: pointer;
            transition: background 0.15s ease;
            position: relative;
            -webkit-app-region: no-drag;
            flex-shrink: 0;
        }

        .tab:hover {
            background: rgba(255, 255, 255, 0.1);
        }

        .tab.active {
            background: rgba(255, 255, 255, 0.12);
        }

        .tab-title {
            flex: 1;
            font-family: 'SF Mono', Menlo, Monaco, 'Courier New', monospace;
            font-size: 11px;
            font-weight: 300;
            letter-spacing: 0.3px;
            color: var(--text-secondary);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            text-align: left;
            user-select: none;
            cursor: pointer;
        }

        .tab.active .tab-title {
            color: var(--text-primary);
        }

        .tab-title-input {
            flex: 1;
            font-family: 'SF Mono', Menlo, Monaco, 'Courier New', monospace;
            font-size: 11px;
            font-weight: 300;
            letter-spacing: 0.3px;
            color: var(--text-primary);
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid var(--accent);
            border-radius: 3px;
            padding: 2px 4px;
            outline: none;
            min-width: 80px;
        }

        .tab-close {
            width: 14px;
            height: 14px;
            border-radius: 3px;
            border: none;
            background: transparent;
            color: var(--text-secondary);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: 0;
            transition: all 0.15s ease;
            margin-left: 6px;
            font-size: 12px;
            -webkit-app-region: no-drag;
        }

        .tab:hover .tab-close,
        .tab.active .tab-close {
            opacity: 0.6;
        }

        .tab-close:hover {
            opacity: 1;
            background: rgba(255, 255, 255, 0.15);
            color: var(--text-primary);
        }

        #new-tab-btn {
            width: 22px;
            height: 22px;
            border-radius: 5px;
            border: none;
            background: rgba(255, 255, 255, 0.05);
            color: var(--text-secondary);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            margin-left: 4px;
            font-size: 14px;
            transition: all 0.15s ease;
            -webkit-app-region: no-drag;
        }

        #new-tab-btn:hover {
            background: rgba(255, 255, 255, 0.12);
            color: var(--text-primary);
        }

        #lock-btn {
            width: 22px;
            height: 22px;
            border-radius: 5px;
            border: none;
            background: rgba(255, 255, 255, 0.05);
            color: var(--text-secondary);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            margin-left: 4px;
            transition: all 0.15s ease;
            -webkit-app-region: no-drag;
            opacity: 0.5;
        }

        #lock-btn:hover {
            background: rgba(255, 255, 255, 0.12);
            color: var(--text-primary);
            opacity: 1;
        }

        #lock-btn.active {
            background: rgba(88, 166, 255, 0.2);
            color: var(--accent);
            opacity: 1;
        }

        #terminals-wrapper {
            flex: 1;
            position: relative;
            overflow: hidden;
            background: var(--bg-primary);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
        }

        .terminal-instance {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            padding: 12px 0 12px 16px;
            visibility: hidden;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .terminal-instance.active {
            visibility: visible;
        }

        .terminal-instance .xterm {
            height: 100%;
            width: 100%;
        }

        .terminal-instance .xterm-screen {
            width: 100% !important;
        }

        .terminal-instance .xterm-viewport {
            background: transparent !important;
        }

        .terminal-instance .xterm-screen {
            background: transparent !important;
        }

        .terminal-instance .xterm-cursor-pointer {
            color: var(--accent) !important;
            text-decoration: underline;
            cursor: pointer;
        }

        .terminal-instance .xterm .xterm-cursor-pointer {
            color: var(--accent) !important;
            text-decoration: underline;
            cursor: pointer;
        }

        .terminal-instance .xterm-cursor-pointer:hover,
        .terminal-instance .xterm .xterm-cursor-pointer:hover {
            opacity: 0.9;
        }

        .terminal-instance .xterm-viewport::-webkit-scrollbar {
            width: 5px;
        }

        .terminal-instance .xterm-viewport::-webkit-scrollbar-track {
            background: transparent;
        }

        .terminal-instance .xterm-viewport::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.15);
            border-radius: 2px;
        }

        .terminal-instance .xterm-viewport::-webkit-scrollbar-thumb:hover {
            background: rgba(255, 255, 255, 0.3);
        }

        .terminal-instance .xterm-viewport {
            scrollbar-gutter: stable;
            margin-right: -20px !important;
            padding-right: 20px !important;
        }

        #context-menu {
            position: fixed;
            display: none;
            background: rgba(255, 255, 255, 0.08);
            border: none;
            border-radius: 10px;
            padding: 5px;
            min-width: 150px;
            z-index: 1000;
            font-family: 'SF Mono', Menlo, Monaco, 'Courier New', monospace;
            overflow: hidden;
        }

        #context-menu.visible {
            display: block;
        }

        .context-menu-item {
            padding: 6px 10px;
            font-size: 11px;
            font-weight: 300;
            color: rgba(255, 255, 255, 0.8);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: space-between;
            transition: background 0.1s ease;
            background: transparent;
            border-radius: 6px;
        }

        .context-menu-item:hover {
            background: rgba(255, 255, 255, 0.1);
        }

        .context-menu-item .shortcut {
            font-size: 9px;
            color: rgba(255, 255, 255, 0.35);
            margin-left: 16px;
        }

        .context-menu-divider {
            height: 1px;
            background: rgba(255, 255, 255, 0.08);
            margin: 4px 6px;
        }

        #shortcut-picker {
            position: fixed;
            display: none;
            background: rgba(255, 255, 255, 0.1);
            border: none;
            border-radius: 8px;
            padding: 4px;
            min-width: 200px;
            max-width: 350px;
            max-height: 200px;
            overflow-y: auto;
            z-index: 1000;
            font-family: 'SF Mono', Menlo, Monaco, 'Courier New', monospace;
        }

        #shortcut-picker.visible {
            display: block;
        }

        .shortcut-item {
            padding: 6px 10px;
            font-size: 11px;
            font-weight: 300;
            color: rgba(255, 255, 255, 0.8);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: space-between;
            border-radius: 5px;
            transition: background 0.1s ease;
        }

        .shortcut-item:hover,
        .shortcut-item.selected {
            background: rgba(255, 255, 255, 0.15);
        }

        .shortcut-item .shortcut-name {
            color: #ffd43b;
            margin-right: 12px;
        }

        .shortcut-item .shortcut-cmd {
            color: rgba(255, 255, 255, 0.5);
            font-size: 10px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            max-width: 180px;
        }

        #shortcut-picker-empty {
            padding: 10px;
            font-size: 11px;
            color: rgba(255, 255, 255, 0.5);
            text-align: center;
        }

        .picker-header {
            padding: 6px 10px;
            font-size: 10px;
            color: rgba(255, 150, 150, 0.8);
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            margin-bottom: 4px;
        }

        /* Command Palette Styles */
        #command-palette-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.4);
            display: none;
            align-items: flex-start;
            justify-content: center;
            padding-top: 15vh;
            z-index: 2000;
        }

        #command-palette-overlay.visible {
            display: flex;
        }

        #command-palette {
            width: 100%;
            max-width: 500px;
            background: rgba(30, 30, 30, 0.85);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            overflow: hidden;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
            font-family: 'SF Mono', Menlo, Monaco, 'Courier New', monospace;
        }

        #command-palette-input-wrapper {
            padding: 12px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.08);
        }

        #command-palette-input {
            width: 100%;
            height: 32px;
            background: rgba(255, 255, 255, 0.06);
            border: none;
            border-radius: 6px;
            padding: 0 12px;
            font-family: 'SF Mono', Menlo, Monaco, 'Courier New', monospace;
            font-size: 13px;
            font-weight: 300;
            color: var(--text-primary);
            outline: none;
            transition: background 0.15s ease;
        }

        #command-palette-input:focus {
            background: rgba(255, 255, 255, 0.1);
        }

        #command-palette-input::placeholder {
            color: rgba(255, 255, 255, 0.35);
        }

        #command-palette-list {
            max-height: 300px;
            overflow-y: auto;
            padding: 6px;
        }

        #command-palette-list::-webkit-scrollbar {
            width: 5px;
        }

        #command-palette-list::-webkit-scrollbar-track {
            background: transparent;
        }

        #command-palette-list::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.15);
            border-radius: 2px;
        }

        .command-palette-item {
            padding: 8px 12px;
            font-size: 12px;
            font-weight: 300;
            color: rgba(255, 255, 255, 0.9);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: space-between;
            border-radius: 6px;
            transition: background 0.1s ease;
        }

        .command-palette-item:hover,
        .command-palette-item.selected {
            background: rgba(255, 255, 255, 0.12);
        }

        .command-palette-item .palette-name {
            color: #ffd43b;
            flex-shrink: 0;
        }

        .command-palette-item .palette-command {
            color: rgba(255, 255, 255, 0.4);
            font-size: 11px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            margin-left: 16px;
            max-width: 280px;
        }

        #command-palette-empty {
            padding: 20px;
            font-size: 12px;
            color: rgba(255, 255, 255, 0.4);
            text-align: center;
        }

        .split-container {
            display: flex;
            width: 100%;
            height: 100%;
            flex: 1 1 0;
            min-width: 0;
            min-height: 0;
        }

        .split-container.vertical {
            flex-direction: row;
        }

        .split-container.horizontal {
            flex-direction: column;
        }

        .pane {
            flex: 1;
            position: relative;
            min-width: 80px;
            min-height: 0;
            display: flex;
            overflow: hidden;
            height: 100%;
            max-width: 100%;
            background: transparent;
            transition: background 0.15s ease, box-shadow 0.15s ease;
        }

        .pane-focused {
            background: var(--bg-accent-focused);
        }

        .pane-terminal {
            flex: 1;
            padding: 8px 20px 8px 8px;
            height: 100%;
            min-height: 0;
            overflow: hidden;
            width: 100%;
            max-width: 100%;
        }

        .split-divider {
            background: rgba(255, 255, 255, 0.03);
            flex-shrink: 0;
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .split-divider::after {
            content: '';
            position: absolute;
            background: rgba(255, 255, 255, 0.15);
            border-radius: 2px;
            transition: background 0.15s ease;
        }

        .split-divider:hover::after {
            background: rgba(255, 255, 255, 0.3);
        }

        .split-container.vertical > .split-divider {
            width: 1px;
            cursor: col-resize;
        }

        .split-container.vertical > .split-divider::after {
            width: 4px;
            height: 40px;
        }

        .split-container.horizontal > .split-divider {
            height: 1px;
            cursor: row-resize;
        }

        .split-container.horizontal > .split-divider::after {
            width: 40px;
            height: 4px;
        }

        /* Search bar styles */
        #search-bar {
            display: none;
            height: 36px;
            background: transparent;
            border-bottom: 1px solid rgba(255, 255, 255, 0.06);
            z-index: 100;
            align-items: center;
            padding: 0 16px;
            gap: 6px;
            font-family: 'SF Mono', Menlo, Monaco, 'Courier New', monospace;
            flex-shrink: 0;
        }

        #search-bar.visible {
            display: flex;
        }

        .search-left {
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .search-spacer {
            flex: 1;
        }

        #search-input {
            width: 200px;
            height: 24px;
            background: rgba(255, 255, 255, 0.06);
            border: none;
            border-radius: 5px;
            padding: 0 10px;
            font-family: 'SF Mono', Menlo, Monaco, 'Courier New', monospace;
            font-size: 11px;
            font-weight: 300;
            color: var(--text-primary);
            outline: none;
            transition: background 0.15s ease;
        }

        #search-input:focus {
            background: rgba(255, 255, 255, 0.1);
        }

        #search-input::placeholder {
            color: rgba(255, 255, 255, 0.35);
        }

        #search-count {
            font-size: 10px;
            font-weight: 300;
            color: var(--text-secondary);
            margin-left: 4px;
        }

        .search-btn {
            width: 22px;
            height: 22px;
            border-radius: 4px;
            border: none;
            background: transparent;
            color: var(--text-secondary);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.15s ease;
        }

        .search-btn:hover {
            background: rgba(255, 255, 255, 0.1);
            color: var(--text-primary);
        }

        .search-btn:disabled {
            opacity: 0.3;
            cursor: not-allowed;
        }

        .search-btn svg {
            width: 12px;
            height: 12px;
            stroke: currentColor;
            stroke-width: 2;
            fill: none;
        }


        /* Search highlight decoration in terminal */
        .xterm .xterm-decoration-search-match {
            background: rgba(255, 213, 0, 0.35);
            border-radius: 2px;
        }

        .xterm .xterm-decoration-search-current {
            background: rgba(255, 150, 0, 0.6);
            border-radius: 2px;
            box-shadow: 0 0 0 1px rgba(255, 150, 0, 0.8);
        }

        /* Clickable URL styles */
        .xterm a {
            color: var(--accent);
            text-decoration: none;
            cursor: pointer;
        }

        .xterm a:hover {
            text-decoration: underline;
        }
    </style>
</head>
<body>
    <div id="titlebar">
        <div id="tabs"></div>
        <button id="new-tab-btn" title="New Tab (Cmd+T)">+</button>
        <button id="lock-btn" title="Always on Top (Cmd+L)">
            <svg viewBox="0 0 24 24" width="12" height="12" fill="none" stroke="currentColor" stroke-width="2.5">
                <rect x="5" y="11" width="14" height="10" rx="2"/>
                <path d="M7 11V7a5 5 0 0 1 10 0v4"/>
            </svg>
        </button>
    </div>
    <div id="search-bar">
        <div class="search-left">
            <input type="text" id="search-input" placeholder="Find...">
            <button class="search-btn" id="search-prev" title="Previous (Shift+Enter)">
                <svg viewBox="0 0 24 24"><polyline points="18 15 12 9 6 15"></polyline></svg>
            </button>
            <button class="search-btn" id="search-next" title="Next (Enter)">
                <svg viewBox="0 0 24 24"><polyline points="6 9 12 15 18 9"></polyline></svg>
            </button>
            <span id="search-count"></span>
        </div>
        <div class="search-spacer"></div>
        <button class="search-btn" id="search-close" title="Close (Escape)">
            <svg viewBox="0 0 24 24"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg>
        </button>
    </div>
    <div id="terminals-wrapper"></div>

    <div id="context-menu">
        <div class="context-menu-item" data-action="split-vertical">
            <span>Split Vertical</span>
        </div>
        <div class="context-menu-item" data-action="split-horizontal">
            <span>Split Horizontal</span>
        </div>
        <div class="context-menu-item" data-action="close-pane">
            <span>Close Terminal</span>
        </div>
    </div>

    <div id="shortcut-picker"></div>

    <div id="command-palette-overlay">
        <div id="command-palette">
            <div id="command-palette-input-wrapper">
                <input type="text" id="command-palette-input" placeholder="Search commands...">
            </div>
            <div id="command-palette-list"></div>
        </div>
    </div>

    <script>
        const { Terminal } = require('@xterm/xterm');
        const { FitAddon } = require('@xterm/addon-fit');
        const { WebLinksAddon } = require('@xterm/addon-web-links');
        const { SearchAddon } = require('@xterm/addon-search');
        const pty = require('node-pty');
        const { ipcRenderer } = require('electron');

        const URL_SCHEME_RE = /^[a-zA-Z][a-zA-Z\d+\-.]*:/;

        function normalizeExternalUrl(url) {
            if (typeof url !== 'string') return null;
            const trimmed = url.trim();
            if (!trimmed) return null;

            const withScheme = URL_SCHEME_RE.test(trimmed) || trimmed.startsWith('//')
                ? trimmed
                : `https://${trimmed}`;

            try {
                return new URL(withScheme).toString();
            } catch {
                return null;
            }
        }

        function openExternalUrl(url) {
            const normalizedUrl = normalizeExternalUrl(url);
            if (!normalizedUrl) return;
            ipcRenderer.invoke('open-external-url', normalizedUrl);
        }

        // URL handler for opening links in default browser
        function handleUrlClick(event, url) {
            if (event) {
                event.preventDefault();
                event.stopPropagation();
            }
            openExternalUrl(url);
        }

        const state = {
            tabs: new Map(),
            tabOrder: [],
            activeTabId: null,
            activePaneId: null,
            nextTabId: 0,
            nextPaneId: 0,
            tabCwds: new Map(), // Track cwd for each tab
            tabCustomNames: new Map(), // Track custom names for tabs
            search: {
                visible: false,
                matches: [],
                currentIndex: -1,
                query: ''
            }
        };

        // Search functionality
        const searchBar = document.getElementById('search-bar');
        const searchInput = document.getElementById('search-input');
        const searchCount = document.getElementById('search-count');
        const searchPrevBtn = document.getElementById('search-prev');
        const searchNextBtn = document.getElementById('search-next');
        const searchCloseBtn = document.getElementById('search-close');
        const terminalsWrapper = document.getElementById('terminals-wrapper');

        function openSearch() {
            state.search.visible = true;
            searchBar.classList.add('visible');
            searchInput.focus();
            searchInput.select();

            // Refit terminals after layout change
            setTimeout(() => {
                const tabData = state.tabs.get(state.activeTabId);
                if (tabData) fitAllPanes(tabData, true);
            }, 50);
        }

        function closeSearch() {
            state.search.visible = false;
            searchBar.classList.remove('visible');
            searchInput.value = '';
            state.search.query = '';
            state.search.matches = [];
            state.search.currentIndex = -1;
            searchCount.textContent = '';

            // Clear all highlights
            clearSearchHighlights();

            // Refit terminals and refocus
            setTimeout(() => {
                const tabData = state.tabs.get(state.activeTabId);
                if (tabData) {
                    fitAllPanes(tabData, true);
                    const pane = tabData.panes.get(state.activePaneId);
                    if (pane) pane.term.focus();
                }
            }, 50);
        }

        function clearSearchHighlights() {
            const tabData = state.tabs.get(state.activeTabId);
            if (!tabData) return;

            tabData.panes.forEach(pane => {
                pane.term.clearSelection();
            });
        }

        function getActivePane() {
            const tabData = state.tabs.get(state.activeTabId);
            if (!tabData) return null;
            return tabData.panes.get(state.activePaneId);
        }

        function setActivePane(paneId, options = {}) {
            const { focusPane = false } = options;
            state.activePaneId = paneId;

            document.querySelectorAll('.pane').forEach((pane) => {
                pane.classList.remove('pane-focused');
            });

            const tabData = state.tabs.get(state.activeTabId);
            const paneData = tabData ? tabData.panes.get(paneId) : null;

            if (paneData && paneData.element && tabData && tabData.panes.size > 1) {
                paneData.element.classList.add('pane-focused');
            }

            if (focusPane && paneData && paneData.term) {
                requestAnimationFrame(() => paneData.term.focus());
            }
        }

        function performSearch(query) {
            state.search.query = query;
            state.search.matches = [];
            state.search.currentIndex = -1;

            clearSearchHighlights();

            if (!query) {
                searchCount.textContent = '';
                updateSearchButtons();
                return;
            }

            const pane = getActivePane();
            if (!pane) return;

            const term = pane.term;
            const buffer = term.buffer.active;
            const searchLower = query.toLowerCase();

            // Search through all lines in the buffer
            for (let y = 0; y < buffer.length; y++) {
                const line = buffer.getLine(y);
                if (!line) continue;

                const lineText = line.translateToString();
                const lineLower = lineText.toLowerCase();

                let startIndex = 0;
                while (true) {
                    const foundIndex = lineLower.indexOf(searchLower, startIndex);
                    if (foundIndex === -1) break;

                    state.search.matches.push({
                        row: y,
                        col: foundIndex,
                        length: query.length
                    });
                    startIndex = foundIndex + 1;
                }
            }

            // Jump to first match
            if (state.search.matches.length > 0) {
                state.search.currentIndex = 0;
                jumpToMatch(0);
            }

            updateSearchCount();
            updateSearchButtons();
        }

        function jumpToMatch(index) {
            if (state.search.matches.length === 0) return;

            const pane = getActivePane();
            if (!pane) return;

            const match = state.search.matches[index];
            const term = pane.term;

            // Scroll to the match (center it in view)
            const viewportHeight = term.rows;
            const targetScrollTop = match.row - Math.floor(viewportHeight / 2);
            term.scrollToLine(Math.max(0, targetScrollTop));

            // Highlight using selection
            term.select(match.col, match.row, match.length);

            updateSearchCount();
        }

        function searchNext() {
            if (state.search.matches.length === 0) return;
            state.search.currentIndex = (state.search.currentIndex + 1) % state.search.matches.length;
            jumpToMatch(state.search.currentIndex);
        }

        function searchPrev() {
            if (state.search.matches.length === 0) return;
            state.search.currentIndex = (state.search.currentIndex - 1 + state.search.matches.length) % state.search.matches.length;
            jumpToMatch(state.search.currentIndex);
        }

        function updateSearchCount() {
            if (state.search.matches.length === 0) {
                searchCount.textContent = state.search.query ? 'No matches' : '';
            } else {
                searchCount.textContent = `${state.search.currentIndex + 1} of ${state.search.matches.length}`;
            }
        }

        function updateSearchButtons() {
            const hasMatches = state.search.matches.length > 0;
            searchPrevBtn.disabled = !hasMatches;
            searchNextBtn.disabled = !hasMatches;
        }

        // Debounce utility to prevent excessive fit() calls
        function debounce(fn, delay) {
            let timeoutId;
            return function(...args) {
                clearTimeout(timeoutId);
                timeoutId = setTimeout(() => fn.apply(this, args), delay);
            };
        }

        // Throttle utility for drag operations
        function throttle(fn, delay) {
            let lastCall = 0;
            let scheduled = null;
            return function(...args) {
                const now = Date.now();
                if (now - lastCall >= delay) {
                    lastCall = now;
                    fn.apply(this, args);
                } else if (!scheduled) {
                    scheduled = setTimeout(() => {
                        lastCall = Date.now();
                        scheduled = null;
                        fn.apply(this, args);
                    }, delay - (now - lastCall));
                }
            };
        }

        // Common Commands storage
        const shortcuts = JSON.parse(localStorage.getItem('terminalShortcuts') || '{}');

        // Extract folder name from path
        function getFolderName(path) {
            if (!path) return 'Terminal';
            // Remove trailing slash and get last component
            const cleaned = path.replace(/\/+$/, '');
            const parts = cleaned.split('/');
            return parts[parts.length - 1] || 'Terminal';
        }

        // Update all tab titles based on cwds
        function updateAllTabTitles() {
            // Count how many tabs have each folder name
            const folderCounts = new Map();
            const tabFolders = new Map();

            state.tabOrder.forEach(tabId => {
                const cwd = state.tabCwds.get(tabId) || process.env.HOME;
                const folderName = getFolderName(cwd);
                tabFolders.set(tabId, folderName);
                folderCounts.set(folderName, (folderCounts.get(folderName) || 0) + 1);
            });

            // Track which index we're at for each folder name
            const folderIndices = new Map();

            state.tabOrder.forEach(tabId => {
                // Use custom name if set, otherwise use folder-based name
                let title;
                if (state.tabCustomNames.has(tabId)) {
                    title = state.tabCustomNames.get(tabId);
                } else {
                    const folderName = tabFolders.get(tabId);
                    const count = folderCounts.get(folderName);

                    if (count > 1) {
                        const idx = (folderIndices.get(folderName) || 0) + 1;
                        folderIndices.set(folderName, idx);
                        title = `${folderName} ${idx}`;
                    } else {
                        title = folderName;
                    }
                }

                const tabEl = document.querySelector(`.tab[data-id="${tabId}"] .tab-title`);
                if (tabEl) tabEl.textContent = title;
            });
        }

        // Parse OSC sequences for directory changes
        function extractCwdFromOSC(data) {
            // OSC 7 format: \x1b]7;file://hostname/path\x07 or \x1b]7;file://hostname/path\x1b\\
            const osc7Match = data.match(/\x1b\]7;file:\/\/[^\/]*([^\x07\x1b]*)/);
            if (osc7Match) {
                return decodeURIComponent(osc7Match[1]);
            }

            // OSC 0/1/2 format (window title): \x1b]0;title\x07 - often contains path
            // Many shells set title to user@host:path or just path
            const oscTitleMatch = data.match(/\x1b\][012];([^\x07\x1b]*)/);
            if (oscTitleMatch) {
                const title = oscTitleMatch[1];
                // Check if it looks like a path (starts with / or ~)
                if (title.startsWith('/')) {
                    return title;
                }
                // Check for user@host:path format
                const colonPath = title.match(/:([\/~][^\x07\x1b]*)$/);
                if (colonPath) {
                    let path = colonPath[1];
                    if (path.startsWith('~')) {
                        path = process.env.HOME + path.slice(1);
                    }
                    return path;
                }
            }
            return null;
        }

        function saveShortcuts() {
            localStorage.setItem('terminalShortcuts', JSON.stringify(shortcuts));
        }

        function startShortcutCreation(ptyProcess, term, paneId) {
            // Clear the line
            ptyProcess.write('\x15');

            term.write('\r\n\x1b[36m┌─ Create Shortcut ─────────────────────┐\x1b[0m\r\n');
            term.write('\x1b[36m│\x1b[0m Shortcut name (e.g. test): ');

            let step = 'name';
            let shortcutName = '';
            let shortcutCommand = '';
            let inputBuffer = '';

            const originalHandler = term._core._inputHandler;

            const handleInput = (data) => {
                if (data === '\r') {
                    if (step === 'name') {
                        shortcutName = inputBuffer.trim();
                        if (!shortcutName) {
                            term.write('\r\n\x1b[31mCancelled.\x1b[0m\r\n');
                            ptyProcess.write('\r');
                            term.onData.disposable?.dispose();
                            return true;
                        }
                        inputBuffer = '';
                        step = 'command';
                        term.write('\r\n\x1b[36m│\x1b[0m Command to run: ');
                    } else if (step === 'command') {
                        shortcutCommand = inputBuffer.trim();
                        if (!shortcutCommand) {
                            term.write('\r\n\x1b[31mCancelled.\x1b[0m\r\n');
                            ptyProcess.write('\r');
                            return true;
                        }
                        shortcuts[shortcutName] = shortcutCommand;
                        saveShortcuts();
                        term.write('\r\n\x1b[36m└─────────────────────────────────────────┘\x1b[0m\r\n');
                        term.write(`\x1b[32m✓ Shortcut created: /${shortcutName} → ${shortcutCommand}\x1b[0m\r\n`);
                        ptyProcess.write('\r');
                        return true;
                    }
                } else if (data === '\x7f') {
                    if (inputBuffer.length > 0) {
                        inputBuffer = inputBuffer.slice(0, -1);
                        term.write('\b \b');
                    }
                } else if (data === '\x03') {
                    term.write('\r\n\x1b[31mCancelled.\x1b[0m\r\n');
                    ptyProcess.write('\r');
                    return true;
                } else if (data.charCodeAt(0) >= 32) {
                    inputBuffer += data;
                    term.write(data);
                }
                return false;
            };

            // Store handler for this pane
            state.ccMode = state.ccMode || {};
            state.ccMode[paneId] = handleInput;
        }

        // Shortcut picker state
        const shortcutPicker = {
            visible: false,
            selectedIndex: 0,
            items: [],
            paneId: null,
            ptyProcess: null,
            term: null,
            deleteMode: false,
            confirmingDelete: false,
            pendingDeleteKey: null
        };

        const pickerElement = document.getElementById('shortcut-picker');

        function showShortcutPicker(term, ptyProcess, paneId, deleteMode = false) {
            const keys = Object.keys(shortcuts);
            if (keys.length === 0) {
                pickerElement.innerHTML = `<div id="shortcut-picker-empty">No shortcuts yet. Use "cc" to create one.</div>`;
            } else {
                shortcutPicker.items = keys;
                shortcutPicker.selectedIndex = 0;
                renderPickerItems();
            }

            shortcutPicker.visible = true;
            shortcutPicker.paneId = paneId;
            shortcutPicker.ptyProcess = ptyProcess;
            shortcutPicker.term = term;
            shortcutPicker.deleteMode = deleteMode;
            shortcutPicker.confirmingDelete = false;
            shortcutPicker.pendingDeleteKey = null;

            // Position near cursor (bottom left of terminal area)
            const termWrapper = document.getElementById('terminals-wrapper');
            const rect = termWrapper.getBoundingClientRect();
            pickerElement.style.left = (rect.left + 20) + 'px';
            pickerElement.style.bottom = '20px';
            pickerElement.style.top = 'auto';

            pickerElement.classList.add('visible');
        }

        function hideShortcutPicker() {
            shortcutPicker.visible = false;
            shortcutPicker.items = [];
            pickerElement.classList.remove('visible');
        }

        function renderPickerItems() {
            const header = shortcutPicker.deleteMode ?
                `<div class="picker-header">Select shortcut to delete</div>` : '';

            pickerElement.innerHTML = header + shortcutPicker.items.map((key, i) => `
                <div class="shortcut-item ${i === shortcutPicker.selectedIndex ? 'selected' : ''}" data-index="${i}">
                    <span class="shortcut-name">/${key}</span>
                    <span class="shortcut-cmd">${shortcuts[key]}</span>
                </div>
            `).join('');

            // Add click handlers
            pickerElement.querySelectorAll('.shortcut-item').forEach(item => {
                item.addEventListener('click', () => {
                    shortcutPicker.selectedIndex = parseInt(item.dataset.index);
                    selectShortcut();
                });
            });
        }

        function navigatePicker(direction) {
            if (shortcutPicker.items.length === 0) return;
            shortcutPicker.selectedIndex += direction;
            if (shortcutPicker.selectedIndex < 0) shortcutPicker.selectedIndex = shortcutPicker.items.length - 1;
            if (shortcutPicker.selectedIndex >= shortcutPicker.items.length) shortcutPicker.selectedIndex = 0;
            renderPickerItems();
        }

        function selectShortcut() {
            if (shortcutPicker.items.length === 0) {
                hideShortcutPicker();
                return;
            }
            const selectedKey = shortcutPicker.items[shortcutPicker.selectedIndex];

            if (shortcutPicker.deleteMode) {
                // Show confirmation in picker
                shortcutPicker.confirmingDelete = true;
                shortcutPicker.pendingDeleteKey = selectedKey;
                pickerElement.innerHTML = `
                    <div class="picker-header">Delete /${selectedKey}?</div>
                    <div class="shortcut-item" style="justify-content: center; color: rgba(255,255,255,0.6);">
                        Press <span style="color: #69db7c; margin: 0 4px;">y</span> to confirm or <span style="color: #ff6b6b; margin: 0 4px;">n</span> to cancel
                    </div>
                `;
                return;
            }

            const command = shortcuts[selectedKey];

            // Clear current input and run command
            shortcutPicker.ptyProcess.write('\x15');
            shortcutPicker.ptyProcess.write(command + '\r');

            hideShortcutPicker();
        }

        // Command Palette state and functionality
        const commandPalette = {
            visible: false,
            selectedIndex: 0,
            filteredItems: [],
            allItems: []
        };

        const paletteOverlay = document.getElementById('command-palette-overlay');
        const paletteInput = document.getElementById('command-palette-input');
        const paletteList = document.getElementById('command-palette-list');

        function openCommandPalette() {
            // Get all shortcuts
            const keys = Object.keys(shortcuts);
            commandPalette.allItems = keys.map(key => ({
                name: key,
                command: shortcuts[key]
            }));
            commandPalette.filteredItems = [...commandPalette.allItems];
            commandPalette.selectedIndex = 0;
            commandPalette.visible = true;

            paletteInput.value = '';
            renderCommandPaletteItems();
            paletteOverlay.classList.add('visible');
            paletteInput.focus();
        }

        function closeCommandPalette() {
            commandPalette.visible = false;
            paletteOverlay.classList.remove('visible');
            paletteInput.value = '';

            // Refocus the active terminal
            const tabData = state.tabs.get(state.activeTabId);
            if (tabData) {
                const pane = tabData.panes.get(state.activePaneId);
                if (pane) pane.term.focus();
            }
        }

        function filterCommandPalette(query) {
            const lowerQuery = query.toLowerCase();
            if (!query) {
                commandPalette.filteredItems = [...commandPalette.allItems];
            } else {
                commandPalette.filteredItems = commandPalette.allItems.filter(item =>
                    item.name.toLowerCase().includes(lowerQuery) ||
                    item.command.toLowerCase().includes(lowerQuery)
                );
            }
            commandPalette.selectedIndex = 0;
            renderCommandPaletteItems();
        }

        function renderCommandPaletteItems() {
            if (commandPalette.filteredItems.length === 0) {
                paletteList.innerHTML = `<div id="command-palette-empty">No matching commands</div>`;
                return;
            }

            paletteList.innerHTML = commandPalette.filteredItems.map((item, i) => `
                <div class="command-palette-item ${i === commandPalette.selectedIndex ? 'selected' : ''}" data-index="${i}">
                    <span class="palette-name">${item.name}</span>
                    <span class="palette-command">${item.command}</span>
                </div>
            `).join('');

            // Add click handlers
            paletteList.querySelectorAll('.command-palette-item').forEach(el => {
                el.addEventListener('click', () => {
                    commandPalette.selectedIndex = parseInt(el.dataset.index);
                    executeCommandPaletteItem();
                });
            });

            // Ensure selected item is visible
            const selectedEl = paletteList.querySelector('.command-palette-item.selected');
            if (selectedEl) {
                selectedEl.scrollIntoView({ block: 'nearest' });
            }
        }

        function navigateCommandPalette(direction) {
            if (commandPalette.filteredItems.length === 0) return;
            commandPalette.selectedIndex += direction;
            if (commandPalette.selectedIndex < 0) {
                commandPalette.selectedIndex = commandPalette.filteredItems.length - 1;
            }
            if (commandPalette.selectedIndex >= commandPalette.filteredItems.length) {
                commandPalette.selectedIndex = 0;
            }
            renderCommandPaletteItems();
        }

        function executeCommandPaletteItem() {
            if (commandPalette.filteredItems.length === 0) {
                closeCommandPalette();
                return;
            }

            const item = commandPalette.filteredItems[commandPalette.selectedIndex];
            const command = item.command;

            // Get the active pane's pty
            const tabData = state.tabs.get(state.activeTabId);
            if (tabData) {
                const pane = tabData.panes.get(state.activePaneId);
                if (pane) {
                    // Clear current line and execute command (same as shortcut picker)
                    pane.pty.write('\x15');
                    pane.pty.write(command + '\r');
                }
            }

            closeCommandPalette();
        }

        // Command palette event listeners
        paletteInput.addEventListener('input', (e) => {
            filterCommandPalette(e.target.value);
        });

        paletteInput.addEventListener('keydown', (e) => {
            if (e.key === 'ArrowDown') {
                e.preventDefault();
                navigateCommandPalette(1);
            } else if (e.key === 'ArrowUp') {
                e.preventDefault();
                navigateCommandPalette(-1);
            } else if (e.key === 'Enter') {
                e.preventDefault();
                executeCommandPaletteItem();
            } else if (e.key === 'Escape') {
                e.preventDefault();
                closeCommandPalette();
            }
        });

        // Close palette when clicking overlay background
        paletteOverlay.addEventListener('click', (e) => {
            if (e.target === paletteOverlay) {
                closeCommandPalette();
            }
        });

        async function openFolderPicker(ptyProcess, term) {
            try {
                // Clear the current line first (Ctrl+U)
                ptyProcess.write('\x15');

                const folderPath = await ipcRenderer.invoke('open-folder-dialog');
                if (folderPath) {
                    // Send cd command to the shell
                    ptyProcess.write(`cd "${folderPath}"\r`);
                } else {
                    // User cancelled, just show a new prompt
                    ptyProcess.write('\r');
                }
            } catch (err) {
                term.write('\x1b[31mError opening folder picker\x1b[0m\r\n');
            }
        }

        const terminalConfig = {
            cursorBlink: true,
            cursorStyle: 'bar',
            fontSize: 13,
            fontFamily: 'Menlo, Monaco, "Courier New", monospace',
            lineHeight: 1.2,
            theme: {
                background: 'transparent',
                foreground: '#ffffff',
                cursor: '#ffffff',
                cursorAccent: 'transparent',
                selectionBackground: '#c4b5fd',
                selectionForeground: '#1a1a2e',
                black: '#686868',
                red: '#ff6b6b',
                green: '#69db7c',
                yellow: '#ffd43b',
                blue: '#74c0fc',
                magenta: '#da77f2',
                cyan: '#66d9e8',
                white: '#e9ecef',
                brightBlack: '#868e96',
                brightRed: '#ff8787',
                brightGreen: '#8ce99a',
                brightYellow: '#ffe066',
                brightBlue: '#a5d8ff',
                brightMagenta: '#e599f7',
                brightCyan: '#99e9f2',
                brightWhite: '#ffffff'
            },
            allowTransparency: true,
            scrollback: 10000
        };

        function createTerminalInPane(paneElement, initialCwd = null) {
            const paneId = state.nextPaneId++;
            paneElement.dataset.paneId = paneId;

            const termContainer = document.createElement('div');
            termContainer.className = 'pane-terminal';
            paneElement.appendChild(termContainer);

            const term = new Terminal(terminalConfig);
            const fitAddon = new FitAddon();
            term.loadAddon(fitAddon);

            // Add web links addon for clickable URLs
            const webLinksAddon = new WebLinksAddon(handleUrlClick);
            term.loadAddon(webLinksAddon);

            // Add search addon for find functionality
            const searchAddon = new SearchAddon();
            term.loadAddon(searchAddon);

            term.open(termContainer);

            // Fallback link handling in case xterm click routing is interrupted.
            termContainer.addEventListener('click', (e) => {
                const anchor = e.target?.closest?.('a');
                if (!anchor || !termContainer.contains(anchor)) return;

                e.preventDefault();
                e.stopPropagation();
                openExternalUrl(anchor.getAttribute('href') || anchor.textContent || '');
            }, true);

            setTimeout(() => fitAddon.fit(), 0);

            const shell = process.env.SHELL || '/bin/zsh';
            const startCwd = initialCwd || process.env.HOME;
            let ptyProcess;

            try {
                ptyProcess = pty.spawn(shell, ['-l'], {
                    name: 'xterm-256color',
                    cols: term.cols || 80,
                    rows: term.rows || 24,
                    cwd: startCwd,
                    env: { ...process.env, TERM: 'xterm-256color' }
                });
            } catch (err) {
                console.error('Failed to spawn PTY:', err);
                term.write('\r\n\x1b[31mError: Failed to start shell\x1b[0m\r\n');
                return null;
            }

            let inputBuffer = '';

            term.onData(data => {
                // Check if in cc mode (creating shortcut)
                if (state.ccMode && state.ccMode[paneId]) {
                    const done = state.ccMode[paneId](data);
                    if (done) {
                        delete state.ccMode[paneId];
                    }
                    return;
                }

                // Handle shortcut picker navigation
                if (shortcutPicker.visible && shortcutPicker.paneId === paneId) {
                    // Handle delete confirmation
                    if (shortcutPicker.confirmingDelete) {
                        if (data === 'y' || data === 'Y') {
                            // Delete the shortcut
                            const keyToDelete = shortcutPicker.pendingDeleteKey;
                            delete shortcuts[keyToDelete];
                            saveShortcuts();
                            term.write(`\r\n\x1b[32m✓ Deleted shortcut: /${keyToDelete}\x1b[0m\r\n`);
                            hideShortcutPicker();
                            ptyProcess.write('\r');
                            inputBuffer = '';
                            return;
                        } else if (data === 'n' || data === 'N' || data === '\x1b' || data === '\x03') {
                            // Cancel - go back to picker
                            shortcutPicker.confirmingDelete = false;
                            shortcutPicker.pendingDeleteKey = null;
                            renderPickerItems();
                            return;
                        }
                        // Ignore other keys during confirmation
                        return;
                    }

                    // Arrow up
                    if (data === '\x1b[A') {
                        navigatePicker(-1);
                        return;
                    }
                    // Arrow down
                    if (data === '\x1b[B') {
                        navigatePicker(1);
                        return;
                    }
                    // Enter - select
                    if (data === '\r') {
                        selectShortcut();
                        inputBuffer = '';
                        return;
                    }
                    // Escape or Ctrl+C - cancel
                    if (data === '\x1b' || data === '\x03') {
                        hideShortcutPicker();
                        ptyProcess.write('\x15');
                        ptyProcess.write('\r');
                        inputBuffer = '';
                        return;
                    }
                    // Any other key closes picker and continues
                    hideShortcutPicker();
                }

                // Check for custom commands on Enter
                if (data === '\r') {
                    const cmd = inputBuffer.trim();

                    // "finder" command - open folder picker
                    if (cmd === 'finder') {
                        term.write('\r\n');
                        openFolderPicker(ptyProcess, term);
                        inputBuffer = '';
                        return;
                    }

                    // "cc" command - create new shortcut
                    if (cmd === 'cc') {
                        startShortcutCreation(ptyProcess, term, paneId);
                        inputBuffer = '';
                        return;
                    }

                    // "cc list" or just "/" - show shortcut picker
                    if (cmd === 'cc list' || cmd === '/') {
                        ptyProcess.write('\x15');
                        showShortcutPicker(term, ptyProcess, paneId);
                        inputBuffer = '';
                        return;
                    }

                    // "cc del" - open picker in delete mode
                    if (cmd === 'cc del') {
                        ptyProcess.write('\x15');
                        showShortcutPicker(term, ptyProcess, paneId, true);
                        inputBuffer = '';
                        return;
                    }

                    // "cc delete <name>" - delete a shortcut (legacy)
                    if (cmd.startsWith('cc delete ')) {
                        const name = cmd.slice(10).trim();
                        ptyProcess.write('\x15');
                        if (shortcuts[name]) {
                            delete shortcuts[name];
                            saveShortcuts();
                            term.write(`\r\n\x1b[32m✓ Deleted shortcut: /${name}\x1b[0m\r\n`);
                        } else {
                            term.write(`\r\n\x1b[31m✗ Shortcut not found: ${name}\x1b[0m\r\n`);
                        }
                        ptyProcess.write('\r');
                        inputBuffer = '';
                        return;
                    }

                    // Check for "/shortcut" commands (direct execution)
                    if (cmd.startsWith('/') && cmd.length > 1) {
                        const shortcutName = cmd.slice(1);
                        if (shortcuts[shortcutName]) {
                            ptyProcess.write('\x15');
                            ptyProcess.write(shortcuts[shortcutName] + '\r');
                            inputBuffer = '';
                            return;
                        }
                    }

                    inputBuffer = '';
                } else if (data === '\x7f') {
                    // Backspace
                    inputBuffer = inputBuffer.slice(0, -1);
                } else if (data.charCodeAt(0) >= 32) {
                    inputBuffer += data;
                } else if (data === '\x03' || data === '\x15') {
                    // Ctrl+C or Ctrl+U clears buffer
                    inputBuffer = '';
                    if (state.ccMode && state.ccMode[paneId]) {
                        delete state.ccMode[paneId];
                    }
                    hideShortcutPicker();
                }
                ptyProcess.write(data);
            });

            ptyProcess.onData(data => {
                term.write(data);
                // Check for OSC 7 directory change sequences
                const newCwd = extractCwdFromOSC(data);
                if (newCwd && state.tabCwds.get(state.activeTabId) !== newCwd) {
                    state.tabCwds.set(state.activeTabId, newCwd);
                    updateAllTabTitles();
                }
            });
            term.onResize(({ cols, rows }) => ptyProcess.resize(cols, rows));
            if (term.textarea) {
                term.textarea.addEventListener('focus', () => {
                    setActivePane(paneId);
                });
            }

            // Focus tracking and click-to-position
            termContainer.addEventListener('mousedown', (e) => {
                if (e.target?.closest?.('a')) return;
                setActivePane(paneId);

                // Skip if it's a selection drag (will be handled by mouseup)
                // Store the mousedown position for comparison
                termContainer._clickStart = { x: e.clientX, y: e.clientY };
            });

            termContainer.addEventListener('mouseup', (e) => {
                if (e.target?.closest?.('a')) return;
                // Check if this was a click (not a drag for selection)
                const start = termContainer._clickStart;
                if (!start) return;

                const dx = Math.abs(e.clientX - start.x);
                const dy = Math.abs(e.clientY - start.y);

                // If mouse moved more than 5px, it's a drag/selection, not a click
                if (dx > 5 || dy > 5) return;

                term.focus();

                // Get actual cell dimensions from xterm
                const cellWidth = term._core._renderService.dimensions.css.cell.width;
                const cellHeight = term._core._renderService.dimensions.css.cell.height;

                // Get the viewport element (where the actual terminal content is)
                const viewportEl = termContainer.querySelector('.xterm-screen');
                if (!viewportEl) return;

                const rect = viewportEl.getBoundingClientRect();
                const clickedCol = Math.floor((e.clientX - rect.left) / cellWidth);
                const clickedRow = Math.floor((e.clientY - rect.top) / cellHeight);

                // Click-to-position: move cursor to clicked position on input line
                const buffer = term.buffer.active;
                const cursorY = buffer.cursorY + buffer.viewportY;
                const cursorX = buffer.cursorX;
                const clickedRowAbsolute = clickedRow + buffer.viewportY;

                // Only handle clicks on the current cursor line
                if (clickedRowAbsolute !== cursorY) return;

                const line = buffer.getLine(cursorY);
                if (!line) return;

                const lineText = line.translateToString();
                const lineEnd = lineText.trimEnd().length;

                // Find prompt end
                let promptEnd = 0;
                const promptPatterns = ['% ', '$ ', '> ', '# ', '❯ ', '→ '];
                for (const pattern of promptPatterns) {
                    const idx = lineText.lastIndexOf(pattern);
                    if (idx !== -1 && idx + pattern.length <= lineEnd) {
                        promptEnd = Math.max(promptEnd, idx + pattern.length);
                    }
                }

                // Only handle clicks within the input area
                if (clickedCol < promptEnd || clickedCol > lineEnd) return;

                const targetX = Math.min(clickedCol, lineEnd);
                const delta = targetX - cursorX;

                if (delta === 0) return;

                // Send arrow key sequences to move cursor
                if (delta > 0) {
                    ptyProcess.write('\x1b[C'.repeat(delta));
                } else {
                    ptyProcess.write('\x1b[D'.repeat(-delta));
                }
            });

            const paneData = { id: paneId, term, pty: ptyProcess, fitAddon, searchAddon, element: paneElement, termContainer };

            // Debounced fit function to prevent flickering
            const debouncedFit = debounce(() => {
                try { fitAddon.fit(); } catch (e) {}
            }, 16); // ~60fps cap

            // ResizeObserver for responsive terminal (debounced)
            const resizeObserver = new ResizeObserver(() => {
                debouncedFit();
            });
            resizeObserver.observe(paneElement); // Watch pane, not termContainer to avoid feedback loop
            paneData.resizeObserver = resizeObserver;
            paneData.debouncedFit = debouncedFit;

            // Store in current tab
            const tabData = state.tabs.get(state.activeTabId);
            if (tabData) {
                tabData.panes.set(paneId, paneData);
            }

            setActivePane(paneId, { focusPane: true });

            return paneData;
        }

        function splitPane(direction) {
            const tabData = state.tabs.get(state.activeTabId);
            if (!tabData) return;

            // Find the active pane
            const activePane = tabData.panes.get(state.activePaneId);
            if (!activePane) return;

            const paneElement = activePane.element;
            const parent = paneElement.parentElement;

            // Preserve any existing flex style
            const existingFlex = paneElement.style.flex;

            // Create split container
            const splitContainer = document.createElement('div');
            splitContainer.className = `split-container ${direction}`;
            if (existingFlex) {
                splitContainer.style.flex = existingFlex;
            }

            // Create first pane (will contain the existing terminal)
            const pane1 = document.createElement('div');
            pane1.className = 'pane';
            pane1.dataset.paneId = activePane.id;

            // Move existing terminal content to pane1
            while (paneElement.firstChild) {
                pane1.appendChild(paneElement.firstChild);
            }
            activePane.element = pane1;

            // Create divider
            const divider = document.createElement('div');
            divider.className = 'split-divider';
            setupDividerDrag(divider, direction);

            // Create second pane (new terminal)
            const pane2 = document.createElement('div');
            pane2.className = 'pane';

            // Assemble
            splitContainer.appendChild(pane1);
            splitContainer.appendChild(divider);
            splitContainer.appendChild(pane2);

            // Replace the original pane element
            parent.replaceChild(splitContainer, paneElement);

            // Create new terminal in pane2
            createTerminalInPane(pane2);

            // Refit all terminals in this tab
            setTimeout(() => fitAllPanes(tabData), 50);
        }

        function setupDividerDrag(divider, direction) {
            let startPos, startSizes, siblings;

            divider.addEventListener('mousedown', (e) => {
                e.preventDefault();
                const container = divider.parentElement;

                // Get the two siblings (pane or split-container) adjacent to this divider
                const children = Array.from(container.children);
                const dividerIndex = children.indexOf(divider);
                siblings = [children[dividerIndex - 1], children[dividerIndex + 1]];

                if (!siblings[0] || !siblings[1]) return;

                startPos = direction === 'vertical' ? e.clientX : e.clientY;
                startSizes = siblings.map(s => direction === 'vertical' ? s.offsetWidth : s.offsetHeight);

                // Throttled fit during drag to prevent flickering
                const throttledFit = throttle(() => {
                    const tabData = state.tabs.get(state.activeTabId);
                    if (tabData) fitAllPanes(tabData);
                }, 32); // ~30fps during drag

                const onMouseMove = (e) => {
                    const currentPos = direction === 'vertical' ? e.clientX : e.clientY;
                    const delta = currentPos - startPos;
                    const totalSize = startSizes[0] + startSizes[1];

                    let newSize1 = startSizes[0] + delta;
                    let newSize2 = startSizes[1] - delta;

                    // Minimum size constraints
                    const minSize = direction === 'vertical' ? 80 : 60;
                    if (newSize1 < minSize) { newSize1 = minSize; newSize2 = totalSize - minSize; }
                    if (newSize2 < minSize) { newSize2 = minSize; newSize1 = totalSize - minSize; }

                    siblings[0].style.flex = `0 0 ${newSize1}px`;
                    siblings[1].style.flex = `0 0 ${newSize2}px`;

                    // Refit terminals (throttled)
                    throttledFit();
                };

                const onMouseUp = () => {
                    document.removeEventListener('mousemove', onMouseMove);
                    document.removeEventListener('mouseup', onMouseUp);
                    // Final fit on mouse up to ensure correct sizing
                    const tabData = state.tabs.get(state.activeTabId);
                    if (tabData) fitAllPanes(tabData, true);
                };

                document.addEventListener('mousemove', onMouseMove);
                document.addEventListener('mouseup', onMouseUp);
            });
        }

        function fitAllPanes(tabData, immediate = false) {
            tabData.panes.forEach(pane => {
                if (immediate) {
                    try { pane.fitAddon.fit(); } catch (e) {}
                } else if (pane.debouncedFit) {
                    pane.debouncedFit();
                } else {
                    try { pane.fitAddon.fit(); } catch (e) {}
                }
            });
        }

        function closePane(paneId) {
            const tabData = state.tabs.get(state.activeTabId);
            if (!tabData) return;

            const paneData = tabData.panes.get(paneId);
            if (!paneData) return;

            // If this is the only pane, close the tab instead
            if (tabData.panes.size === 1) {
                closeTab(state.activeTabId);
                return;
            }

            // Kill PTY, dispose terminal, and cleanup observer
            try { paneData.pty.kill(); } catch (e) {}
            if (paneData.resizeObserver) paneData.resizeObserver.disconnect();
            paneData.term.dispose();

            const paneElement = paneData.element;
            const splitContainer = paneElement.parentElement;

            // Find the sibling (the other pane or split-container)
            const children = Array.from(splitContainer.children);
            const sibling = children.find(c => c !== paneElement && !c.classList.contains('split-divider'));

            if (sibling && splitContainer.parentElement) {
                const parent = splitContainer.parentElement;

                // Preserve flex if the split container had one
                if (splitContainer.style.flex) {
                    sibling.style.flex = splitContainer.style.flex;
                } else {
                    sibling.style.flex = '1';
                }

                // Replace split container with the sibling
                parent.replaceChild(sibling, splitContainer);

                // Update pane element reference if sibling is a pane
                if (sibling.classList.contains('pane') && sibling.dataset.paneId) {
                    const siblingPaneData = tabData.panes.get(parseInt(sibling.dataset.paneId));
                    if (siblingPaneData) {
                        siblingPaneData.element = sibling;
                    }
                }
            }

            // Remove from state
            tabData.panes.delete(paneId);

            // Set new active pane
            const remainingPane = tabData.panes.values().next().value;
            if (remainingPane) {
                setActivePane(remainingPane.id, { focusPane: true });
            }

            // Refit all
            setTimeout(() => fitAllPanes(tabData), 50);
        }

        // Tab renaming functionality
        function startTabRename(tabId, titleElement) {
            const currentText = titleElement.textContent;

            // Create input element
            const input = document.createElement('input');
            input.type = 'text';
            input.className = 'tab-title-input';
            input.value = currentText;

            // Replace title with input
            titleElement.style.display = 'none';
            titleElement.parentNode.insertBefore(input, titleElement);

            // Focus and select all text - need to wait for render
            setTimeout(() => {
                input.focus();
                input.select();
            }, 0);

            // Handle completion (Enter or blur)
            const finishRename = () => {
                const newName = input.value.trim();

                if (newName && newName !== currentText) {
                    // Save custom name
                    state.tabCustomNames.set(tabId, newName);
                } else if (!newName) {
                    // If empty, remove custom name (revert to auto name)
                    state.tabCustomNames.delete(tabId);
                }

                // Remove input and show title again
                input.remove();
                titleElement.style.display = '';

                // Update all titles to reflect change
                updateAllTabTitles();
            };

            // Listen for Enter key
            input.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    finishRename();
                } else if (e.key === 'Escape') {
                    e.preventDefault();
                    // Cancel - just remove input without saving
                    input.remove();
                    titleElement.style.display = '';
                }
            });

            // Listen for blur (clicking outside) - but delay it slightly to prevent immediate blur
            setTimeout(() => {
                input.addEventListener('blur', finishRename);
            }, 100);
        }

        function createTab(id) {
            const tab = document.createElement('div');
            tab.className = 'tab';
            tab.dataset.id = id;

            const title = document.createElement('span');
            title.className = 'tab-title';
            title.textContent = `Terminal ${id + 1}`;

            const closeBtn = document.createElement('button');
            closeBtn.className = 'tab-close';
            closeBtn.innerHTML = '×';
            closeBtn.onclick = (e) => {
                e.stopPropagation();
                closeTab(id);
            };

            tab.appendChild(title);
            tab.appendChild(closeBtn);

            // Click handler for switching tabs
            tab.addEventListener('click', (e) => {
                // Don't switch if clicking on the title during rename or close button
                if (e.target.classList.contains('tab-title-input')) return;
                if (e.target.closest('.tab-close')) return;
                switchToTab(id);
            });

            // Double-click handler for renaming
            tab.addEventListener('dblclick', (e) => {
                // Don't rename if clicking on close button
                if (e.target.closest('.tab-close')) return;
                e.preventDefault();
                e.stopPropagation();
                startTabRename(id, title);
            });

            document.getElementById('tabs').appendChild(tab);
            return tab;
        }

        function createTabContent(tabId, initialCwd = null) {
            const wrapper = document.getElementById('terminals-wrapper');

            const container = document.createElement('div');
            container.className = 'terminal-instance active';
            container.dataset.tabId = tabId;
            wrapper.appendChild(container);

            // Create root pane
            const rootPane = document.createElement('div');
            rootPane.className = 'pane';
            container.appendChild(rootPane);

            const tabData = { id: tabId, container, panes: new Map() };
            state.tabs.set(tabId, tabData);
            state.tabOrder.push(tabId);
            state.activeTabId = tabId;

            // Set initial cwd
            const startCwd = initialCwd || process.env.HOME;
            state.tabCwds.set(tabId, startCwd);

            // Create first terminal in root pane
            createTerminalInPane(rootPane, startCwd);

            // Update all tab titles
            updateAllTabTitles();

            return tabData;
        }

        function switchToTab(id) {
            if (!state.tabs.has(id)) return;

            document.querySelectorAll('.tab').forEach(t => {
                t.classList.toggle('active', parseInt(t.dataset.id) === id);
            });

            document.querySelectorAll('.terminal-instance').forEach(c => {
                c.classList.toggle('active', parseInt(c.dataset.tabId) === id);
            });

            state.activeTabId = id;

            const tabData = state.tabs.get(id);
            requestAnimationFrame(() => {
                fitAllPanes(tabData);
                // Focus first pane
                const firstPane = tabData.panes.values().next().value;
                if (firstPane) {
                    setActivePane(firstPane.id, { focusPane: true });
                }
            });
        }

        function closeTab(id) {
            const tabData = state.tabs.get(id);
            if (!tabData) return;

            // Kill all PTYs in this tab
            tabData.panes.forEach(pane => {
                try { pane.pty.kill(); } catch (e) {}
                if (pane.resizeObserver) pane.resizeObserver.disconnect();
                pane.term.dispose();
            });

            tabData.container.remove();
            document.querySelector(`.tab[data-id="${id}"]`)?.remove();

            state.tabs.delete(id);
            state.tabCwds.delete(id);
            state.tabCustomNames.delete(id);
            state.tabOrder = state.tabOrder.filter(i => i !== id);

            if (state.tabOrder.length === 0) {
                // Close the window when last tab is closed
                ipcRenderer.send('close-window');
                return;
            } else {
                if (state.activeTabId === id) {
                    switchToTab(state.tabOrder[state.tabOrder.length - 1]);
                }
                updateAllTabTitles();
            }
        }

        function newTab() {
            // Get current tab's cwd to use for new tab
            const currentCwd = state.tabCwds.get(state.activeTabId) || process.env.HOME;

            document.querySelectorAll('.terminal-instance').forEach(c => c.classList.remove('active'));
            document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));

            const id = state.nextTabId++;
            createTab(id);
            document.querySelector(`.tab[data-id="${id}"]`)?.classList.add('active');

            createTabContent(id, currentCwd);
        }

        function nextTab() {
            if (state.tabOrder.length <= 1) return;
            const idx = state.tabOrder.indexOf(state.activeTabId);
            const nextIdx = (idx + 1) % state.tabOrder.length;
            switchToTab(state.tabOrder[nextIdx]);
        }

        function prevTab() {
            if (state.tabOrder.length <= 1) return;
            const idx = state.tabOrder.indexOf(state.activeTabId);
            const prevIdx = (idx - 1 + state.tabOrder.length) % state.tabOrder.length;
            switchToTab(state.tabOrder[prevIdx]);
        }

        function clearTerminal() {
            const tabData = state.tabs.get(state.activeTabId);
            if (!tabData) return;
            const pane = tabData.panes.get(state.activePaneId);
            if (pane) pane.term.clear();
        }

        // IPC handlers
        ipcRenderer.on('new-tab', newTab);
        ipcRenderer.on('close-tab', () => closeTab(state.activeTabId));
        ipcRenderer.on('next-tab', nextTab);
        ipcRenderer.on('prev-tab', prevTab);
        ipcRenderer.on('clear-terminal', clearTerminal);
        ipcRenderer.on('switch-to-tab-index', (_, index) => {
            if (index < state.tabOrder.length) {
                switchToTab(state.tabOrder[index]);
            }
        });
        ipcRenderer.on('fullscreen-change', (_, isFullscreen) => {
            document.body.classList.toggle('fullscreen', isFullscreen);
        });
        ipcRenderer.on('select-all', () => {
            const activeEl = document.activeElement;
            // Check if search input or command palette input is focused
            if (activeEl && activeEl.tagName === 'INPUT') {
                activeEl.select();
                return;
            }
            // Check if search bar is visible and focus the input
            if (state.search.visible) {
                searchInput.select();
                return;
            }
            // Check if command palette is visible
            if (commandPalette.visible) {
                paletteInput.select();
                return;
            }
            // In terminal: select current line input
            const pane = getActivePane();
            if (pane) {
                const term = pane.term;
                // Clear any existing selection first
                term.clearSelection();

                // Use setTimeout to ensure selection is fully cleared
                setTimeout(() => {
                    const buffer = term.buffer.active;
                    const cursorY = buffer.cursorY + buffer.viewportY;
                    const cursorX = buffer.cursorX;
                    const line = buffer.getLine(cursorY);
                    if (line) {
                        const lineText = line.translateToString();
                        const lineEnd = lineText.trimEnd().length;
                        // Find prompt end by looking for common prompt endings
                        let promptEnd = 0;
                        const promptPatterns = ['% ', '$ ', '> ', '# ', '❯ ', '→ '];
                        for (const pattern of promptPatterns) {
                            const idx = lineText.lastIndexOf(pattern);
                            if (idx !== -1 && idx + pattern.length <= lineEnd) {
                                promptEnd = Math.max(promptEnd, idx + pattern.length);
                            }
                        }
                        // Select from prompt end to end of line content
                        if (lineEnd > promptEnd) {
                            term.select(promptEnd, cursorY, lineEnd - promptEnd);
                        }
                    }
                }, 0);
            }
        });

        // UI event listeners
        document.getElementById('new-tab-btn').onclick = newTab;

        // Always on top toggle
        let alwaysOnTop = false;
        const lockBtn = document.getElementById('lock-btn');

        function toggleAlwaysOnTop() {
            alwaysOnTop = !alwaysOnTop;
            ipcRenderer.invoke('toggle-always-on-top', alwaysOnTop);
            if (alwaysOnTop) {
                lockBtn.classList.add('active');
            } else {
                lockBtn.classList.remove('active');
            }
        }

        lockBtn.onclick = toggleAlwaysOnTop;

        // Debounced window resize handler
        const debouncedWindowResize = debounce(() => {
            state.tabs.forEach(tabData => fitAllPanes(tabData, true));
        }, 50);
        window.addEventListener('resize', debouncedWindowResize);

        // Scroll to bottom when window regains focus
        window.addEventListener('focus', () => {
            const pane = getActivePane();
            if (pane && pane.term) {
                pane.term.scrollToBottom();
            }
        });

        // Also handle visibility change (switching back from other apps/screens)
        document.addEventListener('visibilitychange', () => {
            if (!document.hidden) {
                const pane = getActivePane();
                if (pane && pane.term) {
                    pane.term.scrollToBottom();
                }
            }
        });

        // Context menu
        const contextMenu = document.getElementById('context-menu');

        function showContextMenu(e) {
            e.preventDefault();

            // Find which pane was right-clicked
            const paneTerminal = e.target.closest('.pane-terminal');
            if (paneTerminal) {
                const paneElement = paneTerminal.closest('.pane');
                if (paneElement && paneElement.dataset.paneId) {
                    setActivePane(parseInt(paneElement.dataset.paneId));
                }
            }

            const menuWidth = 150;
            const menuHeight = 70;
            const posX = e.clientX + menuWidth > window.innerWidth ? e.clientX - menuWidth : e.clientX;
            const posY = e.clientY + menuHeight > window.innerHeight ? e.clientY - menuHeight : e.clientY;

            contextMenu.style.left = posX + 'px';
            contextMenu.style.top = posY + 'px';
            contextMenu.classList.add('visible');
        }

        function hideContextMenu() {
            contextMenu.classList.remove('visible');
        }

        document.getElementById('terminals-wrapper').addEventListener('contextmenu', showContextMenu);
        document.addEventListener('click', hideContextMenu);

        // Search event listeners
        const debouncedSearch = debounce((value) => {
            performSearch(value);
        }, 150);

        searchInput.addEventListener('input', (e) => {
            debouncedSearch(e.target.value);
        });

        // Capture phase for Cmd+A to ensure it works
        searchInput.addEventListener('keydown', (e) => {
            if ((e.metaKey || e.ctrlKey) && (e.key === 'a' || e.key === 'A' || e.code === 'KeyA')) {
                e.preventDefault();
                e.stopPropagation();
                e.stopImmediatePropagation();
                setTimeout(() => {
                    searchInput.focus();
                    searchInput.select();
                }, 0);
            }
        }, true);

        searchInput.addEventListener('keydown', (e) => {
            if (e.key === 'Enter' || e.key === 'ArrowDown') {
                e.preventDefault();
                if (e.shiftKey) {
                    searchPrev();
                } else {
                    searchNext();
                }
            } else if (e.key === 'ArrowUp') {
                e.preventDefault();
                searchPrev();
            } else if (e.key === 'Escape') {
                e.preventDefault();
                closeSearch();
            } else if ((e.metaKey || e.ctrlKey) && e.key === 'a') {
                e.stopPropagation();
                searchInput.select();
            }
        });

        searchPrevBtn.addEventListener('click', searchPrev);
        searchNextBtn.addEventListener('click', searchNext);
        searchCloseBtn.addEventListener('click', closeSearch);

        // Global keyboard shortcut for Cmd+F and Cmd+Shift+P
        // Use capture phase to intercept before xterm gets the event
        document.addEventListener('keydown', (e) => {
            // Cmd+L - Toggle Always on Top
            if ((e.metaKey || e.ctrlKey) && !e.shiftKey && e.key === 'l') {
                e.preventDefault();
                e.stopPropagation();
                toggleAlwaysOnTop();
                return;
            }

            // Cmd+Shift+P - Command Palette
            if ((e.metaKey || e.ctrlKey) && e.shiftKey && e.key === 'p') {
                e.preventDefault();
                e.stopPropagation();
                if (commandPalette.visible) {
                    closeCommandPalette();
                } else {
                    openCommandPalette();
                }
                return;
            }

            // Cmd+F - Search
            if ((e.metaKey || e.ctrlKey) && e.key === 'f') {
                e.preventDefault();
                e.stopPropagation();
                if (state.search.visible) {
                    searchInput.focus();
                    searchInput.select();
                } else {
                    openSearch();
                }
            } else if (e.key === 'Escape' && state.search.visible) {
                e.preventDefault();
                e.stopPropagation();
                closeSearch();
            } else if (e.key === 'Escape' && commandPalette.visible) {
                e.preventDefault();
                e.stopPropagation();
                closeCommandPalette();
            }
            // Cmd+A - Select all in input fields
            if ((e.metaKey || e.ctrlKey) && e.key === 'a') {
                const activeEl = document.activeElement;
                if (activeEl && activeEl.tagName === 'INPUT') {
                    e.preventDefault();
                    e.stopPropagation();
                    activeEl.setSelectionRange(0, activeEl.value.length);
                    return;
                }
            }

            // Cmd+Shift+Left - Select from cursor to start of input
            if ((e.metaKey || e.ctrlKey) && e.shiftKey && e.key === 'ArrowLeft' && !state.search.visible && !commandPalette.visible) {
                const pane = getActivePane();
                if (pane) {
                    e.preventDefault();
                    e.stopPropagation();
                    const term = pane.term;
                    const buffer = term.buffer.active;
                    const cursorY = buffer.cursorY + buffer.viewportY;
                    const cursorX = buffer.cursorX;
                    const line = buffer.getLine(cursorY);
                    if (line) {
                        const lineText = line.translateToString();
                        let promptEnd = 0;
                        const promptPatterns = ['% ', '$ ', '> ', '# ', '❯ ', '→ '];
                        for (const pattern of promptPatterns) {
                            const idx = lineText.lastIndexOf(pattern);
                            if (idx !== -1 && idx + pattern.length <= cursorX) {
                                promptEnd = Math.max(promptEnd, idx + pattern.length);
                            }
                        }
                        if (cursorX > promptEnd) {
                            term.select(promptEnd, cursorY, cursorX - promptEnd);
                        }
                    }
                }
            }

            // Cmd+Shift+Right - Select from cursor to end of input
            if ((e.metaKey || e.ctrlKey) && e.shiftKey && e.key === 'ArrowRight' && !state.search.visible && !commandPalette.visible) {
                const pane = getActivePane();
                if (pane) {
                    e.preventDefault();
                    e.stopPropagation();
                    const term = pane.term;
                    const buffer = term.buffer.active;
                    const cursorY = buffer.cursorY + buffer.viewportY;
                    const cursorX = buffer.cursorX;
                    const line = buffer.getLine(cursorY);
                    if (line) {
                        const lineText = line.translateToString().trimEnd();
                        const lineEnd = lineText.length;
                        if (lineEnd > cursorX) {
                            term.select(cursorX, cursorY, lineEnd - cursorX);
                        }
                    }
                }
            }

            // Backspace with selection - delete selected text only if selection is in input area
            if (e.key === 'Backspace' && !state.search.visible && !commandPalette.visible) {
                const pane = getActivePane();
                if (pane && pane.term.hasSelection()) {
                    const term = pane.term;
                    const selection = term.getSelectionPosition();

                    if (selection) {
                        const buffer = term.buffer.active;
                        // Use selection's Y position, not cursor's Y position
                        const selectionY = selection.start.y;

                        // Check if selection is on a single line
                        const line = buffer.getLine(selectionY);
                        if (line && selection.start.y === selection.end.y) {
                            const lineText = line.translateToString();
                            const lineEnd = lineText.trimEnd().length;

                            // Find prompt end
                            let promptEnd = 0;
                            const promptPatterns = ['% ', '$ ', '> ', '# ', '❯ ', '→ '];
                            for (const pattern of promptPatterns) {
                                const idx = lineText.lastIndexOf(pattern);
                                if (idx !== -1 && idx + pattern.length <= lineEnd) {
                                    promptEnd = Math.max(promptEnd, idx + pattern.length);
                                }
                            }

                            // Only process if selection starts at or after prompt end
                            if (selection.start.x >= promptEnd) {
                                e.preventDefault();
                                e.stopPropagation();

                                // Get the full input text (after prompt to end of line)
                                const inputText = lineText.substring(promptEnd, lineEnd);

                                // Calculate what text should remain using position-based approach
                                const selStart = selection.start.x - promptEnd;
                                const selEnd = selection.end.x - promptEnd;
                                const beforeSelection = inputText.substring(0, selStart);
                                const afterSelection = inputText.substring(selEnd);
                                const newText = beforeSelection + afterSelection;

                                // Clear line and retype
                                pane.pty.write('\x15'); // Ctrl+U to clear
                                if (newText.length > 0) {
                                    pane.pty.write(newText);
                                }

                                term.clearSelection();
                            }
                        }
                    }
                }
            }
        }, true);

        contextMenu.addEventListener('click', (e) => {
            const item = e.target.closest('.context-menu-item');
            if (!item) return;

            const action = item.dataset.action;

            switch (action) {
                case 'split-vertical':
                    splitPane('vertical');
                    break;
                case 'split-horizontal':
                    splitPane('horizontal');
                    break;
                case 'close-pane':
                    closePane(state.activePaneId);
                    break;
            }

            hideContextMenu();
        });

        // Start with one terminal
        try {
            console.log('Creating initial tab...');
            newTab();
            console.log('Initial tab created, tabs:', state.tabs.size);
        } catch (e) {
            console.error('Failed to create initial tab:', e);
            alert('Failed to create terminal: ' + e.message);
        }
    </script>
</body>
</html>
